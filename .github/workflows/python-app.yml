name: Python application
 
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

permissions:
  contents: write  # Change permissions to allow writing back to the repo

# Fichier : .github/workflows/python-app.yml

# ...

jobs:
  # Étape 1 : Build et Lint
  build:
    runs-on: ubuntu-latest
    steps:
      # ... (checkout, setup, install dependencies)
      - uses: actions/checkout@v4
      - name: Set up Python 3.11
      # ... (votre code) ...
      - name: Install dependencies
        run: pip install -r requirements.txt
        
      - name: Lint with Ruff (Check only)
        # On vérifie si les fichiers DOIVENT être formatés (échec si ce n'est pas le cas)
        run: |
          ruff check .
          ruff format --check .  # <--- On remet le --check ici !
      
      - name: Format with Ruff and Commit Changes
        # Cette étape s'exécute SEULEMENT si nous sommes sur la branche 'main' et que l'événement est un push.
        # Elle ne s'exécutera PAS pendant une Pull Request.
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          # 1. Formater (le code sera modifié si nécessaire)
          ruff format .
          
          # 2. Configurer Git et pousser seulement s'il y a des changements
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # 3. Commiter seulement s'il y a des fichiers modifiés
          git add .
          git commit -m "style: Apply automatic ruff formatting" || echo "No formatting changes to commit"
          
          # 4. Pousser vers la branche main
          git push

  # Étape 2 : Test Unitaire
  test-unit:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python 3.11
        uses: actions/setup-python@v3
        with:
          python-version: "3.11"
      - name: Install dependencies
        run: pip install -r requirements.txt
      - name: Run Unit Tests
        run: pytest tests/test_unit.py

  # Étape 3 : Test d'Intégration
  # Fichier : .github/workflows/python-app.yml

# ... autres jobs (build et test-unit)

  # Étape 3 : Test Integration
  test-integration:
    needs: build
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest

    # DÉMARRAGE DU SERVICE POSTGRESQL
    services:
      postgres:
        image: postgres:14-alpine
        env:
          POSTGRES_USER: ci_user
          POSTGRES_PASSWORD: ci_password
          POSTGRES_DB: watertracker_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4
      - name: Set up Python 3.11
        uses: actions/setup-python@v3
        with:
          python-version: "3.11"
      - name: Install dependencies
        run: pip install -r requirements.txt
        
      # CONFIGURATION DE LA BASE DE DONNÉES
      - name: Set DB environment variables
        run: |
          echo "DATABASE_URL=postgresql://ci_user:ci_password@localhost:5432/watertracker_db" >> $GITHUB_ENV
          echo "DATABASE_HOST=localhost" >> $GITHUB_ENV
          echo "DATABASE_PORT=5432" >> $GITHUB_ENV
          echo "DATABASE_USER=ci_user" >> $GITHUB_ENV
          echo "DATABASE_PASSWORD=ci_password" >> $GITHUB_ENV
          echo "DATABASE_NAME=watertracker_db" >> $GITHUB_ENV
      
      - name: Initialize Database
        # Cette commande exécute le script SQL pour créer les tables
        run: |
          # Attendre que Postgres soit prêt (facultatif mais sécurisant)
          sleep 10
          # Exécutez le script d'initialisation de la BDD ici si nécessaire
          python -c "from app.db import init_db; init_db()" # (ou la commande pertinente)

      - name: Run Integration Tests
        run: pytest tests/test_integration.py
